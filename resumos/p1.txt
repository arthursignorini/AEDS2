CONTAR OPERAÇÕES

1- Distributividade = quando tem uma constante dentro do somatório, pode retirar a constante e a multiplicar pelo somatório que restou

2- Associabilidade = quando tem uma soma dentro do somatório, pode fazer uma soma de somatórios
 
3- Comutatividade = a ordem dos fatores não muda, somar do inicio para o fim é a mesma coisa que do fim para o inicio


ALGORITMOS 

* Pesquisa Sequencial = tem complexidade de O(n) - passa por todos os elementos do vetor
* Pesquisa Binária = tem complexidade de O(lg n) - faz lg n + 1 comparações

* O custo do Seleção é de O(n^2) para todos os casos - faz (n^2 - n) / 2 comparações e 3n -3 movimentações
* Esse algoritmo a cada iteração coloca o menor número do array na menor posição disponível, depois considere o array a partir da próxima posição, fazendo isso até o ordenar

* Inserção - insere elementos da parte não ordenada para a parte ordenada - faz uso de variável temporária
* Seu melhor caso é quando a lista já está ordenada e faz n-1 comparações - com complexidade O(n)
* Seu pior caso é quando a lista está invertida, tendo a mesma quantidade de comparações que o Seleção - com complexidade de O(n^2)
* Bom método para ser usado quando o vetor estiver quase ordenado
* Boa opção para adicionar itens em um vetor ordenado - custo linear
* É um algoritmo estável

* BubbleSort - a cada iteração do método = n-1 comparações, uma vez que o maior elemento já está na última posição
* O método bolha coloca o maior elemento na última posição
* O método sempre faz as mesmas comparações mas ele sempre para uma casa antes
* E são necessárias n-1 iterações para que o vetor fique ordenado, dessa forma - (n-1)(n-1) = n^2-2n-1 = O(n^2)
* Melhor caso quando ta ordenado e pior caso quando estiver na ordem decrescente 
* Adaptação para o número de comparações e para o número de iterações (nesse tem que usar o boolean)
* Melhor caso desse método O(n) e pior caso é O(n^2)

 boolean trocou = true;
        while(trocou) {
            for(int i=0; i<tam-1 && trocou; i++) {
                trocou = false;
                for(int j=0; j<tam-1-i; j++) {
                    if(vet[j] > vet[j+1]) {
                        int temp = vet[j+1];
                        vet[j+1] = vet[j];
                        vet[j] = temp;
                        trocou = true;
                    }
                }
            }
        }

TADS LINEARES

* LISTA - inserir e remover elementos em qualquer posição
* Os métodos de inserção recebem o elemento a ser inserido e dependendo a posição também
* Os métodos de remoção não recebem nenhum elemento e apenas retornam o elemento removido

* PILHA - o primeiro elemento a entrar é o último a sair - First in, Last out
* usa os métodos de inserir e remover - empilhar e desempilhar
* Inserir no fim e remover do fim -> isso montaria uma pilha

* FILA - o primeiro a entrar é o primeiro a sair - First in, First out
* Enfileiras e desenfileirar
* Inserir no fim e remover no início - monta uma fila - mas o método de remover do início não é eficiente
* Inserir no início e remover no final - monta uma fila - mas o método de inserir no início não é eficiente
* Por isso se utiliza outra estrutura = FILA CIRCULAR







